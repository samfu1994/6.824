package mapreduce

import (
	"fmt"
	"strconv"
	"strings"
	"unicode"
)
func judgeFunc(r rune) bool{
	if unicode.IsLetter(r) {
			return false
	}
	return true
}
func mapF(document string, value string) (res []KeyValue) {
	// TODO: you have to write this function

	res = make([]KeyValue,0)
	myMap := make(map[string]int);
	words := strings.FieldsFunc(value, judgeFunc);
	length := len(words)

	for i := 0; i < length; i++{
		myMap[words[i]]++;
	}
	count := 0
	var tmp KeyValue;
	for k, v := range myMap{
		tmp.Key = k;
		tmp.Value = strconv.Itoa(v);
		res = append(res, tmp);
		count++;
	}
	return res;
}

// The reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
func reduceF(key string, values []string) string {
	// TODO: you also have to write this function
	length := len(values);
	var resInt int;
	for i := 0; i < length; i++{
		tmp, err := strconv.Atoi(values[i]);
		if err != nil{
			fmt.Println("wrong input for keyvalue's value")
		}
		resInt += tmp;
	}
	return strconv.Itoa(resInt);

}



func createWorker(masterAddr string, workerAddr string,
	MapFunc func(string, string) []KeyValue,
	ReduceFunc func(string, []string) string){
		RunWorker(masterAddr, workerAddr, MapFunc, ReduceFunc, 1);
	
}
// schedule starts and waits for all tasks in the given phase (Map or Reduce).
func (mr *Master) schedule(phase jobPhase) {
	fmt.Println("enter schedule");
	var ntasks int
	var nios int // number of inputs (for reduce) or outputs (for map)
	switch phase {
	case mapPhase:
		ntasks = len(mr.files)
		nios = mr.nReduce
	case reducePhase:
		ntasks = mr.nReduce
		nios = len(mr.files)
	}

	for i := 0; i < ntasks; i++{
		fmt.Println("now on TASK:#####", i)

		createWorker(mr.address, "worker"+strconv.Itoa(i), mapF, reduceF);//wc.go: mapF
		var regArg RegisterArgs;
		regArg.Worker = "worker"+strconv.Itoa(i)
		mr.Register(&regArg, new(struct{}));
		arg := DoTaskArgs{Phase: phase, TaskNumber: i, NumOtherPhase: nios}
		ok := call(mr.workers[i], "Worker.DoTask", arg, new(struct{}))
		if ok != false{
			fmt.Println("can't do task");
		}
	}

	fmt.Printf("Schedule: %v %v tasks (%d I/Os)\n", ntasks, phase, nios)



	// All ntasks tasks have to be scheduled on workers, and only once all of
	// them have been completed successfully should the function return.
	// Remember that workers may fail, and that any given worker may finish
	// multiple tasks.
	//
	// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
	//
	//you should modify schedule() in master.go to hand out the map and 
	//reduce tasks to workers, and return only when all the tasks have finished.
	fmt.Printf("Schedule: %v phase done\n", phase)
}
